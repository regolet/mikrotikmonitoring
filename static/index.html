<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MikroTik Monitoring</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    <link rel="stylesheet" href="/static/css/style.css">
    <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
        <div class="container">
            <a class="navbar-brand" href="/">MikroTik Monitoring</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav me-auto">
                    <li class="nav-item">
                        <a class="nav-link active" href="/" data-page="dashboard">Dashboard</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/groups" data-page="groups">Groups</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/groups-summary" data-page="groups-summary">Groups Summary</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/settings" data-page="settings">Settings</a>
                    </li>
                </ul>
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <div class="d-flex align-items-center">
                            <label for="router-selector" class="text-light me-2">Router:</label>
                            <select id="router-selector" class="form-select form-select-sm" style="width: auto;">
                                <option value="">Loading...</option>
                            </select>
                        </div>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Main Content Container -->
    <div id="main-content">
        <!-- Dashboard Page -->
        <div id="dashboard-page" class="page-content">
            <div class="container-fluid mt-4">
                <!-- Network Summary -->
                <div class="card mb-4">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h3 class="mb-0">Network Summary</h3>
                        <div class="d-flex flex-wrap gap-2">
                            <div class="btn-group">
                                <button type="button" class="btn btn-outline-primary dropdown-toggle" data-bs-toggle="dropdown">
                                    Auto-refresh: <span id="refresh-interval-display">Off</span>
                                </button>
                                <ul class="dropdown-menu dropdown-menu-end">
                                    <li><a class="dropdown-item refresh-option" href="#" data-interval="0">Off</a></li>
                                    <li><a class="dropdown-item refresh-option" href="#" data-interval="5">5 seconds</a></li>
                                    <li><a class="dropdown-item refresh-option" href="#" data-interval="10">10 seconds</a></li>
                                    <li><a class="dropdown-item refresh-option" href="#" data-interval="30">30 seconds</a></li>
                                    <li><a class="dropdown-item refresh-option" href="#" data-interval="60">1 minute</a></li>
                                </ul>
                            </div>
                            <button id="refresh-now" class="btn btn-primary">
                                <i class="bi bi-arrow-clockwise"></i> Refresh Now
                            </button>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="seven-cards-row">
                                                <div class="stat-card-wrapper">
                        <div class="stat-card horizontal-card">
                            <div class="icon-container">
                                <i class="bi bi-people-fill"></i>
                            </div>
                            <div class="card-content">
                                <h3 class="mb-0" id="total-accounts">-</h3>
                                <p class="mb-0">Total Accounts</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="stat-card-wrapper">
                        <div class="stat-card horizontal-card bg-success bg-opacity-10">
                            <div class="icon-container">
                                <i class="bi bi-wifi text-success"></i>
                            </div>
                            <div class="card-content">
                                <h3 class="mb-0 text-success" id="online-accounts">-</h3>
                                <p class="mb-0">Online</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="stat-card-wrapper">
                        <div class="stat-card horizontal-card bg-danger bg-opacity-10">
                            <div class="icon-container">
                                <i class="bi bi-wifi-off text-danger"></i>
                            </div>
                            <div class="card-content">
                                <h3 class="mb-0 text-danger" id="offline-accounts">-</h3>
                                <p class="mb-0">Offline</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="stat-card-wrapper">
                        <div class="stat-card horizontal-card bg-info bg-opacity-10">
                            <div class="icon-container">
                                <i class="bi bi-toggle-on text-info"></i>
                            </div>
                            <div class="card-content">
                                <h3 class="mb-0 text-info" id="enabled-accounts">-</h3>
                                <p class="mb-0">Enabled</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="stat-card-wrapper">
                        <div class="stat-card horizontal-card bg-secondary bg-opacity-10">
                            <div class="icon-container">
                                <i class="bi bi-toggle-off text-secondary"></i>
                            </div>
                            <div class="card-content">
                                <h3 class="mb-0 text-secondary" id="disabled-accounts">-</h3>
                                <p class="mb-0">Disabled</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="stat-card-wrapper">
                        <div class="stat-card horizontal-card bg-info bg-opacity-10">
                            <div class="icon-container">
                                <i class="bi bi-cloud-arrow-up text-info"></i>
                            </div>
                            <div class="card-content">
                                <h3 class="mb-0 text-info" id="total-upload-speed">-</h3>
                                <p class="mb-0">Total Upload Speed</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="stat-card-wrapper">
                        <div class="stat-card horizontal-card bg-primary bg-opacity-10">
                            <div class="icon-container">
                                <i class="bi bi-cloud-arrow-down text-primary"></i>
                            </div>
                            <div class="card-content">
                                <h3 class="mb-0 text-primary" id="total-download-speed">-</h3>
                                <p class="mb-0">Total Download Speed</p>
                            </div>
                        </div>
                    </div>
                        </div>
                        <div class="row">
                            <div class="col-12 text-end">
                                <small class="text-muted">Last updated: <span id="last-updated-time">-</span></small>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- PPPoE Interfaces -->
                <div id="pppoe-section" style="display: none;">
                    <div class="card mb-4">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <div class="d-flex align-items-center gap-2 flex-grow-1">
                                <input id="pppoe-search" type="text" class="form-control form-control-sm" placeholder="Search..." style="max-width: 350px; width: 100%;">
                            </div>
                            <div>
                                <select id="pppoe-rows-per-page" class="form-select form-select-sm">
                                    <option value="10">10 rows</option>
                                    <option value="20" selected>20 rows</option>
                                    <option value="50">50 rows</option>
                                    <option value="100">100 rows</option>
                                    <option value="0">All</option>
                                </select>
                            </div>
                        </div>
                        <div class="card-body">
                            <div class="table-responsive">
                                <table class="table table-striped table-hover table-sm" id="pppoe-interfaces-table">
                                    <thead>
                                        <tr>
                                            <th class="sortable" data-sort="name">
                                                Name <i class="bi bi-arrow-down-up sort-icon"></i>
                                            </th>
                                            <th class="sortable" data-sort="profile">
                                                Profile Plan <i class="bi bi-arrow-down-up sort-icon"></i>
                                            </th>
                                            <th class="sortable" data-sort="status">
                                                Status <i class="bi bi-arrow-down-up sort-icon"></i>
                                            </th>
                                            <th class="sortable" data-sort="download">
                                                Download Speed (Mbps) <i class="bi bi-arrow-down-up sort-icon"></i>
                                            </th>
                                            <th class="sortable" data-sort="upload">
                                                Upload Speed (Mbps) <i class="bi bi-arrow-down-up sort-icon"></i>
                                            </th>
                                            <th class="sortable" data-sort="address">
                                                Address <i class="bi bi-arrow-down-up sort-icon"></i>
                                            </th>
                                            <th class="sortable" data-sort="uptime">
                                                Uptime <i class="bi bi-arrow-down-up sort-icon"></i>
                                            </th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- PPPoE interfaces will be populated by JavaScript -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        <div class="card-footer">
                            <div class="d-flex justify-content-between align-items-center">
                                <div>
                                    Showing <span id="pppoe-showing-start">0</span> to <span id="pppoe-showing-end">0</span> of <span id="pppoe-total-rows">0</span> entries
                                </div>
                                <div>
                                    <nav aria-label="PPPoE table navigation">
                                        <ul class="pagination pagination-sm mb-0">
                                            <li class="page-item">
                                                <button id="pppoe-prev-page" class="page-link" aria-label="Previous">
                                                    <span aria-hidden="true">&laquo;</span>
                                                </button>
                                            </li>
                                            <li class="page-item">
                                                <span class="page-link">Page <span id="pppoe-current-page">1</span></span>
                                            </li>
                                            <li class="page-item">
                                                <button id="pppoe-next-page" class="page-link" aria-label="Next">
                                                    <span aria-hidden="true">&raquo;</span>
                                                </button>
                                            </li>
                                        </ul>
                                    </nav>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Groups Page -->
        <div id="groups-page" class="page-content" style="display: none;">
            <div class="container-fluid mt-4">
                <div class="card">
                    <div class="card-header">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h3>Groups Management</h3>
                            <button class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#addGroupModal">
                                <i class="bi bi-plus-circle"></i> Add Group
                            </button>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="input-group">
                                    <span class="input-group-text">
                                        <i class="bi bi-search"></i>
                                    </span>
                                    <input type="text" class="form-control" id="groups-search" placeholder="Search groups by name, description, or members...">
                                    <button class="btn btn-outline-secondary" type="button" id="clear-search-btn" style="display: none;">
                                        <i class="bi bi-x"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="card-body">
                        <div id="groups-content">
                            <!-- Groups will be populated by JavaScript -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Groups Summary Page -->
        <div id="groups-summary-page" class="page-content" style="display: none;">
            <div class="container-fluid mt-4">
                <h2>Groups Summary</h2>
                <div class="alert alert-info">Groups Summary content will go here.</div>
            </div>
        </div>

        <!-- Settings Page -->
        <div id="settings-page" class="page-content" style="display: none;">
            <div class="container-fluid mt-4">
                <!-- Router Management Section -->
                <div class="card mb-4">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h3>Router Management</h3>
                        <button type="button" class="btn btn-primary" id="add-router-btn">
                            <i class="bi bi-plus-circle"></i> Add Router
                        </button>
                    </div>
                    <div class="card-body">
                        <div class="table-responsive">
                            <table class="table table-striped table-hover" id="routers-table">
                                <thead>
                                    <tr>
                                        <th>Name</th>
                                        <th>Host</th>
                                        <th>Status</th>
                                        <th>Last Connection</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <!-- Routers will be populated by JavaScript -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Legacy Settings Section -->
                <div class="card">
                    <div class="card-header">
                        <h3>Legacy Router Settings</h3>
                        <small class="text-muted">This section will be deprecated in favor of the multi-router system above.</small>
                    </div>
                    <div class="card-body">
                        <form id="settings-form">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="mb-3">
                                        <label for="router_ip" class="form-label">Router IP Address</label>
                                        <input type="text" class="form-control" id="router_ip" name="router_ip" required>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="mb-3">
                                        <label for="router_port" class="form-label">Port</label>
                                        <input type="number" class="form-control" id="router_port" name="router_port" value="8728" required>
                                    </div>
                                </div>
                            </div>
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="mb-3">
                                        <label for="router_user" class="form-label">Username</label>
                                        <input type="text" class="form-control" id="router_user" name="router_user" required>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="mb-3">
                                        <label for="router_password" class="form-label">Password</label>
                                        <input type="password" class="form-control" id="router_password" name="router_password" required>
                                    </div>
                                </div>
                            </div>
                            <div class="d-flex justify-content-between">
                                <button type="submit" class="btn btn-primary">
                                    <i class="bi bi-save"></i> Save Settings
                                </button>
                                <button type="button" class="btn btn-secondary" id="test-connection">
                                    <i class="bi bi-wifi"></i> Test Connection
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Router Modal -->
    <div class="modal fade" id="addRouterModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Add New Router</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <form id="add-router-form">
                        <div class="mb-3">
                            <label for="router-name" class="form-label">Router Name</label>
                            <input type="text" class="form-control" id="router-name" required>
                        </div>
                        <div class="mb-3">
                            <label for="router-description" class="form-label">Description</label>
                            <input type="text" class="form-control" id="router-description">
                        </div>
                        <div class="row">
                            <div class="col-md-8">
                                <div class="mb-3">
                                    <label for="router-host" class="form-label">Host/IP Address</label>
                                    <input type="text" class="form-control" id="router-host" required>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="mb-3">
                                    <label for="router-port" class="form-label">Port</label>
                                    <input type="number" class="form-control" id="router-port" value="8728" required>
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label for="router-username" class="form-label">Username</label>
                                    <input type="text" class="form-control" id="router-username" required>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label for="router-password" class="form-label">Password</label>
                                    <input type="password" class="form-control" id="router-password" required>
                                </div>
                            </div>
                        </div>
                        <div class="mb-3">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="router-ssl">
                                <label class="form-check-label" for="router-ssl">
                                    Use SSL/TLS
                                </label>
                            </div>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="save-router-btn">Save Router</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Edit Router Modal -->
    <div class="modal fade" id="editRouterModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Edit Router</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <form id="edit-router-form">
                        <input type="hidden" id="edit-router-id" name="edit-router-id">
                        <div class="mb-3">
                            <label for="edit-router-name" class="form-label">Router Name</label>
                            <input type="text" class="form-control" id="edit-router-name" name="edit-router-name" required>
                        </div>
                        <div class="mb-3">
                            <label for="edit-router-description" class="form-label">Description</label>
                            <input type="text" class="form-control" id="edit-router-description" name="edit-router-description">
                        </div>
                        <div class="row">
                            <div class="col-md-8">
                                <div class="mb-3">
                                    <label for="edit-router-host" class="form-label">Host/IP Address</label>
                                    <input type="text" class="form-control" id="edit-router-host" name="edit-router-host" required>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="mb-3">
                                    <label for="edit-router-port" class="form-label">Port</label>
                                    <input type="number" class="form-control" id="edit-router-port" name="edit-router-port" value="8728" required>
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label for="edit-router-username" class="form-label">Username</label>
                                    <input type="text" class="form-control" id="edit-router-username" name="edit-router-username" required>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label for="edit-router-password" class="form-label">Password</label>
                                    <input type="password" class="form-control" id="edit-router-password" name="edit-router-password">
                                </div>
                            </div>
                        </div>
                        <div class="mb-3">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="edit-router-ssl" name="edit-router-ssl">
                                <label class="form-check-label" for="edit-router-ssl">
                                    Use SSL/TLS
                                </label>
                            </div>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="update-router-btn">Update Router</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Group Modal -->
    <div class="modal fade" id="addGroupModal" tabindex="-1">
        <div class="modal-dialog modal-lg modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Add New Group</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <form id="add-group-form">
                        <div class="mb-3">
                            <label for="group-name" class="form-label">Group Name</label>
                            <input type="text" class="form-control" id="group-name" required>
                        </div>
                        <div class="mb-3">
                            <label for="group-description" class="form-label">Description</label>
                            <textarea class="form-control" id="group-description" rows="3" placeholder="Enter a description for this group (optional)"></textarea>
                        </div>
                        <div class="mb-3">
                            <label for="group-max-members" class="form-label">Max Members <span class="text-muted small">(optional, blank = no limit)</span></label>
                            <input type="number" class="form-control" id="group-max-members" min="1" placeholder="Leave blank for no limit">
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Group Members</label>
                            <div class="row">
                                <div class="col-md-5">
                                    <label class="form-label text-muted">Available Accounts</label>
                                    <input type="text" class="form-control mb-2" id="available-accounts-search" placeholder="Search accounts...">
                                    <select id="available-accounts" class="form-select" size="12" multiple>
                                        <!-- Available accounts will be populated by JavaScript -->
                                    </select>
                                </div>
                                <div class="col-md-2 d-flex flex-column justify-content-center align-items-center">
                                    <button type="button" class="btn btn-sm btn-outline-primary mb-2" id="add-members">
                                        <i class="bi bi-arrow-right"></i>
                                    </button>
                                    <button type="button" class="btn btn-sm btn-outline-secondary" id="remove-members">
                                        <i class="bi bi-arrow-left"></i>
                                    </button>
                                </div>
                                <div class="col-md-5">
                                    <label class="form-label text-muted">Selected Members</label>
                                    <select id="selected-members" class="form-select" size="12" multiple>
                                        <!-- Selected members will be populated by JavaScript -->
                                    </select>
                                </div>
                            </div>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="save-group-btn">Save Group</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Edit Group Modal -->
    <div class="modal fade" id="editGroupModal" tabindex="-1">
        <div class="modal-dialog modal-lg modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Edit Group</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <form id="edit-group-form">
                        <input type="hidden" id="edit-group-id">
                        <div class="mb-3">
                            <label for="edit-group-name" class="form-label">Group Name</label>
                            <input type="text" class="form-control" id="edit-group-name" required>
                        </div>
                        <div class="mb-3">
                            <label for="edit-group-description" class="form-label">Description</label>
                            <textarea class="form-control" id="edit-group-description" rows="3" placeholder="Enter a description for this group (optional)"></textarea>
                        </div>
                        <div class="mb-3">
                            <label for="edit-group-max-members" class="form-label">Max Members <span class="text-muted small">(optional, blank = no limit)</span></label>
                            <input type="number" class="form-control" id="edit-group-max-members" min="1" placeholder="Leave blank for no limit">
                        </div>
                        <div class="mb-3">
                            <label class="form-label">Group Members</label>
                            <div class="row">
                                <div class="col-md-5">
                                    <label class="form-label text-muted">Available Accounts</label>
                                    <input type="text" class="form-control mb-2" id="edit-available-accounts-search" placeholder="Search accounts...">
                                    <select id="edit-available-accounts" class="form-select" size="12" multiple>
                                        <!-- Available accounts will be populated by JavaScript -->
                                    </select>
                                </div>
                                <div class="col-md-2 d-flex flex-column justify-content-center align-items-center">
                                    <button type="button" class="btn btn-sm btn-outline-primary mb-2" id="edit-add-members">
                                        <i class="bi bi-arrow-right"></i>
                                    </button>
                                    <button type="button" class="btn btn-sm btn-outline-secondary" id="edit-remove-members">
                                        <i class="bi bi-arrow-left"></i>
                                    </button>
                                </div>
                                <div class="col-md-5">
                                    <label class="form-label text-muted">Selected Members</label>
                                    <select id="edit-selected-members" class="form-select" size="12" multiple>
                                        <!-- Selected members will be populated by JavaScript -->
                                    </select>
                                </div>
                            </div>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="update-group-btn">Update Group</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Floating Notification Container -->
    <div id="toast-container" class="toast-container position-fixed top-0 end-0 p-3" style="z-index: 1100;"></div>

    <footer class="footer mt-5">
        <div class="container text-center py-3">
            <p>MikroTik Monitoring &copy; 2024</p>
            <p class="text-muted">Last updated: <span id="footer-time">-</span></p>
        </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Bootstrap Toast Notification Helper -->
    <script>
    function showToast(message, type = 'info', title = '') {
        const toastId = 'toast-' + Date.now();
        const icon = type === 'success' ? 'bi-check-circle-fill' : type === 'error' ? 'bi-x-circle-fill' : type === 'warning' ? 'bi-exclamation-triangle-fill' : 'bi-info-circle-fill';
        const header = title ? `<strong class="me-auto"><i class="bi ${icon} me-2"></i>${title}</strong>` : '';
        const toastHtml = `
            <div id="${toastId}" class="toast align-items-center text-bg-${type === 'error' ? 'danger' : type} border-0 mb-2" role="alert" aria-live="assertive" aria-atomic="true">
                <div class="d-flex">
                    <div class="toast-body">
                        ${header}
                        ${message}
                    </div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                </div>
            </div>`;
        const container = document.getElementById('toast-container');
        container.insertAdjacentHTML('beforeend', toastHtml);
        const toastEl = document.getElementById(toastId);
        const toast = new bootstrap.Toast(toastEl, { delay: 4000 });
        toast.show();
        toastEl.addEventListener('hidden.bs.toast', () => toastEl.remove());
    }
    // Simple aliases for compatibility
    window.showSuccess = (title, message) => showToast(message, 'success', title);
    window.showError = (title, message) => showToast(message, 'danger', title);
    window.showWarning = (title, message) => showToast(message, 'warning', title);
    window.showInfo = (title, message) => showToast(message, 'info', title);
    </script>

    <!-- Main Application Logic -->
    <script>
        class MikroTikSPA {
            constructor() {
                this.currentPage = 'dashboard';
                this.refreshInterval = null;
                this.currentData = {};
                this.pppoePage = 1;
                this.rowsPerPage = 20;
                this.sortColumn = 'download';
                this.sortDirection = 'desc';
                this.groupsData = []; // Store groups data for filtering
                this.currentSearchQuery = ''; // Store current search query
                this.initializingRouters = false; // Flag to suppress router change event
                this.injectCategoryModals(); // Ensure modals are always injected at startup
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.setupRouting();
                this.loadRouters(); // Ensure router selector is always populated
                // this.loadCurrentPage(); // REMOVE this line to prevent double loading
                this.initializeSearchState();
            }

            setupEventListeners() {
                // Navigation
                document.querySelectorAll('[data-page]').forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        const page = e.target.dataset.page;
                        this.navigateTo(page);
                    });
                });

                // Dashboard controls
                document.getElementById('refresh-now')?.addEventListener('click', () => {
                    this.refreshDashboardData();
                });

                // Auto-refresh options
                document.querySelectorAll('.refresh-option').forEach(option => {
                    option.addEventListener('click', (e) => {
                        e.preventDefault();
                        const interval = parseInt(e.target.dataset.interval);
                        this.setRefreshInterval(interval);
                    });
                });

                // Settings form
                document.getElementById('settings-form')?.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.saveSettings();
                });

                document.getElementById('test-connection')?.addEventListener('click', () => {
                    this.testConnection();
                });

                // Groups functionality
                document.getElementById('save-group-btn')?.addEventListener('click', () => {
                    this.saveGroup();
                });

                document.getElementById('update-group-btn')?.addEventListener('click', () => {
                    this.updateGroup();
                });

                // Groups search functionality
                document.getElementById('groups-search')?.addEventListener('input', (e) => {
                    this.currentSearchQuery = e.target.value;
                    this.filterGroups(e.target.value);
                    this.updateClearButton();
                });

                // Clear search functionality
                document.getElementById('clear-search-btn')?.addEventListener('click', () => {
                    this.clearSearch();
                });

                // Dual list select functionality
                document.getElementById('add-members')?.addEventListener('click', () => {
                    this.transferMembers('available-accounts', 'selected-members');
                });

                document.getElementById('remove-members')?.addEventListener('click', () => {
                    this.transferMembers('selected-members', 'available-accounts');
                });

                document.getElementById('edit-add-members')?.addEventListener('click', () => {
                    this.transferMembers('edit-available-accounts', 'edit-selected-members');
                });

                document.getElementById('edit-remove-members')?.addEventListener('click', () => {
                    this.transferMembers('edit-selected-members', 'edit-available-accounts');
                });

                // Modal show events for dual list population
                document.getElementById('addGroupModal')?.addEventListener('show.bs.modal', () => {
                    this.populateAddModal();
                });

                // Note: editGroupModal population is handled in editGroup() method
                // to ensure proper group data is loaded

                // PPPoE table sorting
                document.querySelectorAll('#pppoe-interfaces-table th.sortable').forEach(th => {
                    th.addEventListener('click', (e) => {
                        const sortField = th.dataset.sort;
                        this.sortPPPoETable(sortField);
                    });
                });

                // Add event listener for PPPoE search
                const pppoeSearchInput = document.getElementById('pppoe-search');
                if (pppoeSearchInput) {
                    pppoeSearchInput.addEventListener('input', (e) => {
                        this.filterPPPoETable(e.target.value);
                    });
                }

                // Add event listeners for dual list search inputs
                const addAvailableSearch = document.getElementById('available-accounts-search');
                if (addAvailableSearch) {
                    addAvailableSearch.addEventListener('input', (e) => {
                        this.filterDualList(e.target.value, 'available-accounts');
                    });
                }

                const editAvailableSearch = document.getElementById('edit-available-accounts-search');
                if (editAvailableSearch) {
                    editAvailableSearch.addEventListener('input', (e) => {
                        this.filterDualList(e.target.value, 'edit-available-accounts');
                    });
                }

                // Router management functionality
                document.getElementById('add-router-btn')?.addEventListener('click', () => {
                    this.showAddRouterModal();
                });

                document.getElementById('save-router-btn')?.addEventListener('click', () => {
                    this.saveRouter();
                });

                document.getElementById('update-router-btn')?.addEventListener('click', () => {
                    this.updateRouter();
                });

                // Router selector
                const routerSelector = document.getElementById('router-selector');
                if (routerSelector) {
                    routerSelector.addEventListener('change', (e) => {
                        if (this.initializingRouters) return; // Skip if initializing
                        this.switchRouter(e.target.value);
                    });
                }
            }

            setupRouting() {
                // Handle browser back/forward
                window.addEventListener('popstate', (e) => {
                    const page = e.state?.page || 'dashboard';
                    this.navigateTo(page, true);
                });

                // Initial route
                const path = window.location.pathname;
                if (path === '/settings') {
                    this.navigateTo('settings');
                } else if (path === '/groups') {
                    this.navigateTo('groups');
                } else if (path === '/groups-summary') {
                    this.navigateTo('groups-summary');
                } else {
                    this.navigateTo('dashboard');
                }
            }

            navigateTo(page, fromPopState = false) {
                this.currentPage = page;
                this.showPage(page);
                if (!fromPopState) {
                    window.history.pushState({ page }, '', `/${page === 'dashboard' ? '' : page}`);
                }
                // Update navigation active state
                document.querySelectorAll('.nav-link').forEach(link => {
                    link.classList.remove('active');
                });
                document.querySelector(`[data-page="${page}"]`)?.classList.add('active');
            }

            showPage(page) {
                // Hide all pages
                document.querySelectorAll('.page-content').forEach(content => {
                    content.style.display = 'none';
                });

                // Show selected page
                const pageElement = document.getElementById(`${page}-page`);
                if (pageElement) {
                    pageElement.style.display = 'block';
                }

                // Load page-specific data
                this.loadCurrentPage();
            }

            loadCurrentPage() {
                switch (this.currentPage) {
                    case 'dashboard':
                        this.loadDashboardData();
                        break;
                    case 'groups':
                        this.loadGroups();
                        break;
                    case 'groups-summary':
                        this.loadCategoriesForSummary();
                        break;
                    case 'settings':
                        this.loadSettings();
                        this.loadRouters();
                        break;
                }
            }

            async loadDashboardData() {
                await this.checkConnection();
                if (this.currentData.connected) {
                    await this.refreshDashboardData();
                }
            }

            async checkConnection() {
                try {
                    const activeRouter = await this.getActiveRouter();
                    const routerId = activeRouter?.active_router_id;
                    const url = routerId ? `/api/status?router_id=${routerId}` : '/api/status';
                    
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    this.currentData.connected = data.connected;
                    
                    if (data.connected) {
                        showSuccess('Connected', `Successfully connected to ${data.router_name || 'MikroTik router'}`);
                    } else {
                        showError('Connection Failed', 'Unable to connect to MikroTik router');
                    }
                } catch (error) {
                    console.error('Error checking connection:', error);
                    showError('Connection Error', 'Failed to connect to server');
                }
            }

            async refreshDashboardData() {
                try {
                    const activeRouter = await this.getActiveRouter();
                    const routerId = activeRouter?.active_router_id;
                    const url = routerId ? `/api/pppoe?router_id=${routerId}` : '/api/pppoe';
                    
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    if (data.success) {
                        this.currentData.pppoe = data;
                        this.updateDashboard();
                    } else {
                        showError('Data Error', data.error || 'Failed to load data');
                    }
                } catch (error) {
                    console.error('Error refreshing data:', error);
                    showError('Refresh Error', 'Failed to refresh data');
                }
            }

            updateDashboard() {
                if (this.currentData.pppoe && this.currentData.pppoe.aggregate_stats) {
                    const stats = this.currentData.pppoe.aggregate_stats;
                    document.getElementById('total-accounts').textContent = stats.total_accounts || 0;
                    document.getElementById('online-accounts').textContent = stats.online_accounts || 0;
                    document.getElementById('offline-accounts').textContent = stats.offline_accounts || 0;
                    document.getElementById('enabled-accounts').textContent = stats.enabled_accounts || 0;
                    document.getElementById('disabled-accounts').textContent = stats.disabled_accounts || 0;
                }

                // Update PPPoE table and calculate speeds
                const processedInterfaces = this.updatePPPoETable();
                this.updateSpeedCalculations(processedInterfaces);
                // Reapply PPPoE search filter after table update
                const searchInput = document.getElementById('pppoe-search');
                if (searchInput) {
                    this.filterPPPoETable(searchInput.value);
                }
                this.updateFooter();
            }

            updatePPPoETable() {
                const section = document.getElementById('pppoe-section');
                const tbody = document.querySelector('#pppoe-interfaces-table tbody');
                
                if (!this.currentData.pppoe || !this.currentData.pppoe.pppoe_interfaces) {
                    section.style.display = 'none';
                    return [];
                }

                const interfaces = this.currentData.pppoe.pppoe_interfaces;
                const pppSecrets = this.currentData.pppoe.ppp_secrets || [];
                const pppActive = this.currentData.pppoe.ppp_active || [];
                
                // Create a map of PPP secrets for quick lookup
                const pppAccountMap = {};
                pppSecrets.forEach(acc => {
                    if (acc.name) pppAccountMap[acc.name.toLowerCase()] = acc;
                    if (acc.username) pppAccountMap[acc.username.toLowerCase()] = acc;
                });

                // Build a map for quick lookup by name and address
                const pppActiveMap = {};
                pppActive.forEach(entry => {
                    if (entry.name) pppActiveMap[entry.name.toLowerCase()] = entry;
                    if (entry.address) pppActiveMap[entry.address] = entry;
                });

                // Process interfaces with speed calculations and account matching
                const processedInterfaces = interfaces.map(iface => {
                    // Try to match PPPoE interface name to PPP account
                    let accountName = iface.name || 'N/A';
                    let profilePlan = iface.profile || 'N/A';
                    
                    // Extract username from interface name if it matches <pppoe-username> pattern
                    const match = iface.name.match(/^<pppoe-(.+)>$/i);
                    if (match && match[1]) {
                        const username = match[1].toLowerCase();
                        const account = pppAccountMap[username];
                        if (account) {
                            accountName = account.name || account.username || iface.name;
                            profilePlan = account.profile || 'N/A';
                        }
                    } else {
                        // Try direct name matching
                        const account = pppAccountMap[iface.name.toLowerCase()];
                        if (account) {
                            accountName = account.name || account.username || iface.name;
                            profilePlan = account.profile || 'N/A';
                        }
                    }
                    
                    // Calculate speeds for this interface
                    const rxBytes = parseFloat(iface['rx-byte'] || 0);
                    const txBytes = parseFloat(iface['tx-byte'] || 0);
                    
                    // Calculate rates using localStorage pattern
                    let calculatedRxRateBps = 0;
                    let calculatedTxRateBps = 0;
                    
                    const interfaceName = iface.name;
                    const storageKey = `pppoe_stats_${interfaceName}`;
                    const currentTime = Date.now();
                    
                    // Get previous stats from localStorage
                    const prevStatsStr = localStorage.getItem(storageKey);
                    if (prevStatsStr) {
                        try {
                            const prevStats = JSON.parse(prevStatsStr);
                            const timeDiff = (currentTime - prevStats.timestamp) / 1000;
                            
                            if (timeDiff > 0) {
                                let rxDiff = rxBytes - prevStats.rxBytes;
                                let txDiff = txBytes - prevStats.txBytes;
                                
                                // Handle counter wrapping
                                rxDiff = rxDiff < 0 ? rxBytes : rxDiff;
                                txDiff = txDiff < 0 ? txBytes : txDiff;
                                
                                calculatedRxRateBps = Math.max(0, rxDiff / timeDiff);
                                calculatedTxRateBps = Math.max(0, txDiff / timeDiff);
                            }
                        } catch (e) {
                            console.warn('Error parsing previous stats for', interfaceName, e);
                        }
                    }
                    
                    // Store current values for next calculation
                    const currentStats = {
                        rxBytes: rxBytes,
                        txBytes: txBytes,
                        timestamp: currentTime
                    };
                    localStorage.setItem(storageKey, JSON.stringify(currentStats));
                    
                    return {
                        ...iface,
                        accountName: accountName,
                        profilePlan: profilePlan,
                        calculatedRxRateBps: calculatedRxRateBps,
                        calculatedTxRateBps: calculatedTxRateBps,
                        status: iface.running === 'true' ? 'Up' : 'Down',
                        statusClass: iface.running === 'true' ? 'status-up' : 'status-down'
                    };
                });

                // Sort the processed interfaces
                this.sortInterfaces(processedInterfaces);

                const total = processedInterfaces.length;
                const start = (this.pppoePage - 1) * this.rowsPerPage;
                const end = Math.min(start + this.rowsPerPage, total);
                const pageData = processedInterfaces.slice(start, end);

                if (total > 0) {
                    section.style.display = 'block';
                    tbody.innerHTML = pageData.map(iface => {
                        // Try to find a matching PPP active entry
                        let activeEntry = null;
                        if (iface.accountName && pppActiveMap[iface.accountName.toLowerCase()]) {
                            activeEntry = pppActiveMap[iface.accountName.toLowerCase()];
                        } else if (iface.address && pppActiveMap[iface.address]) {
                            activeEntry = pppActiveMap[iface.address];
                        }
                        const address = activeEntry ? (activeEntry.address || activeEntry['remote-address']) : (iface.address || iface['remote-address']);
                        const uptime = activeEntry ? activeEntry.uptime : (iface.uptime || iface['uptime']);
                        return `
                            <tr class="${iface.running === 'true' ? 'table-default' : 'table-secondary'}">
                                <td>${iface.accountName}</td>
                                <td>${iface.profilePlan}</td>
                                <td>
                                    <span class="status-indicator ${iface.statusClass}"></span>
                                    ${iface.status}
                                </td>
                                <td>${this.formatMbps(iface.calculatedTxRateBps)}</td>
                                <td>${this.formatMbps(iface.calculatedRxRateBps)}</td>
                                <td>${address || 'N/A'}</td>
                                <td>${uptime || 'N/A'}</td>
                            </tr>
                        `;
                    }).join('');

                    // Update pagination info
                    document.getElementById('pppoe-showing-start').textContent = total === 0 ? 0 : start + 1;
                    document.getElementById('pppoe-showing-end').textContent = end;
                    document.getElementById('pppoe-total-rows').textContent = total;
                    document.getElementById('pppoe-current-page').textContent = this.pppoePage;
                    
                    // Set up pagination controls
                    const prevBtn = document.getElementById('pppoe-prev-page');
                    const nextBtn = document.getElementById('pppoe-next-page');
                    const rowsSelect = document.getElementById('pppoe-rows-per-page');
                    
                    if (prevBtn) {
                        prevBtn.onclick = () => {
                            if (this.pppoePage > 1) {
                                this.pppoePage--;
                                this.updatePPPoETable();
                            }
                        };
                    }
                    
                    if (nextBtn) {
                        nextBtn.onclick = () => {
                            const totalPages = Math.ceil(total / this.rowsPerPage);
                            if (this.pppoePage < totalPages) {
                                this.pppoePage++;
                                this.updatePPPoETable();
                            }
                        };
                    }
                    
                    if (rowsSelect) {
                        rowsSelect.onchange = () => {
                            this.rowsPerPage = parseInt(rowsSelect.value) || 20;
                            this.pppoePage = 1;
                            this.updatePPPoETable();
                        };
                    }
                } else {
                    section.style.display = 'none';
                }
                
                return processedInterfaces;
            }

            sortPPPoETable(sortField) {
                // Toggle sort direction if same column
                if (this.sortColumn === sortField) {
                    this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
                } else {
                    this.sortColumn = sortField;
                    this.sortDirection = 'asc';
                }

                // Update sort icons
                document.querySelectorAll('#pppoe-interfaces-table th.sortable').forEach(th => {
                    const icon = th.querySelector('.sort-icon');
                    if (th.dataset.sort === sortField) {
                        icon.className = this.sortDirection === 'asc' ? 'bi bi-arrow-up sort-icon' : 'bi bi-arrow-down sort-icon';
                    } else {
                        icon.className = 'bi bi-arrow-down-up sort-icon';
                    }
                });

                // Reset to first page when sorting
                this.pppoePage = 1;
                
                // Update the table
                this.updatePPPoETable();
            }

            sortInterfaces(interfaces) {
                interfaces.sort((a, b) => {
                    let aValue, bValue;
                    
                    switch (this.sortColumn) {
                        case 'name':
                            aValue = a.accountName.toLowerCase();
                            bValue = b.accountName.toLowerCase();
                            break;
                        case 'profile':
                            aValue = a.profilePlan.toLowerCase();
                            bValue = b.profilePlan.toLowerCase();
                            break;
                        case 'status':
                            aValue = a.status.toLowerCase();
                            bValue = b.status.toLowerCase();
                            break;
                        case 'download':
                            aValue = a.calculatedTxRateBps;
                            bValue = b.calculatedTxRateBps;
                            break;
                        case 'upload':
                            aValue = a.calculatedRxRateBps;
                            bValue = b.calculatedRxRateBps;
                            break;
                        case 'address':
                            aValue = this.ipToNumber(a.address || a['remote-address']);
                            bValue = this.ipToNumber(b.address || b['remote-address']);
                            break;
                        case 'uptime':
                            aValue = this.uptimeToSeconds(a.uptime || a['uptime']);
                            bValue = this.uptimeToSeconds(b.uptime || b['uptime']);
                            break;
                        default:
                            aValue = a.accountName.toLowerCase();
                            bValue = b.accountName.toLowerCase();
                    }
                    
                    // Handle numeric sorting
                    if (this.sortColumn === 'download' || this.sortColumn === 'upload') {
                        if (this.sortDirection === 'asc') {
                            return aValue - bValue;
                        } else {
                            return bValue - aValue;
                        }
                    }
                    
                    // Handle string sorting
                    if (typeof aValue === 'string' && typeof bValue === 'string') {
                        if (this.sortDirection === 'asc') {
                            return aValue.localeCompare(bValue);
                        } else {
                            return bValue.localeCompare(aValue);
                        }
                    } else {
                        // Numeric or mixed types
                        if (this.sortDirection === 'asc') {
                            return aValue - bValue;
                        } else {
                            return bValue - aValue;
                        }
                    }
                });
            }

            updateSpeedCalculations(processedInterfaces = null) {
                if (!processedInterfaces || processedInterfaces.length === 0) {
                    document.getElementById('total-upload-speed').textContent = '-';
                    document.getElementById('total-download-speed').textContent = '-';
                    return;
                }

                let totalDownloadRate = 0;
                let totalUploadRate = 0;

                // Use the processed interfaces that already have speed calculations
                processedInterfaces.forEach(iface => {
                    totalDownloadRate += iface.calculatedTxRateBps || 0;
                    totalUploadRate += iface.calculatedRxRateBps || 0;
                });

                // Update total speed displays
                document.getElementById('total-download-speed').textContent = this.formatMbps(totalDownloadRate);
                document.getElementById('total-upload-speed').textContent = this.formatMbps(totalUploadRate);
            }

            async loadGroups() {
                try {
                    const activeRouter = await this.getActiveRouter();
                    const routerId = activeRouter?.active_router_id;
                    const groupsUrl = routerId ? `/api/groups?router_id=${routerId}` : '/api/groups';
                    const pppActiveUrl = routerId ? `/api/ppp_active?router_id=${routerId}` : '/api/ppp_active';
                    
                    // Fetch both groups and PPP active data
                    const [groupsResponse, pppActiveResponse] = await Promise.all([
                        fetch(groupsUrl),
                        fetch(pppActiveUrl)
                    ]);
                    
                    const groupsData = await groupsResponse.json();
                    const pppActiveData = await pppActiveResponse.json();
                    
                    if (groupsData.success) {
                        const groups = groupsData.groups || [];
                        const pppActive = pppActiveData.success ? pppActiveData.ppp_active || [] : [];
                        
                        // Create a set of online usernames for quick lookup
                        const onlineUsernames = new Set(pppActive.map(conn => conn.name));
                        
                        // Add online status to each group's accounts
                        groups.forEach(group => {
                            if (group.accounts) {
                                group.accounts = group.accounts.map(account => ({
                                    name: account,
                                    online: onlineUsernames.has(account)
                                }));
                            }
                        });
                        
                        // Store groups data for filtering
                        this.groupsData = groups;
                        this.renderGroups(groups, this.currentSearchQuery);
                        
                        // Restore search input value if there was a previous search
                        const searchInput = document.getElementById('groups-search');
                        if (searchInput && this.currentSearchQuery) {
                            searchInput.value = this.currentSearchQuery;
                        }
                        this.updateClearButton();
                    } else {
                        showError('Groups Error', groupsData.error || 'Failed to load groups');
                    }
                } catch (error) {
                    console.error('Error loading groups:', error);
                    showError('Groups Error', 'Failed to load groups');
                }
            }

            filterGroups(searchQuery) {
                if (this.groupsData.length === 0) return;
                this.renderGroups(this.groupsData, searchQuery);
            }

            updateClearButton() {
                const clearBtn = document.getElementById('clear-search-btn');
                if (clearBtn) {
                    clearBtn.style.display = this.currentSearchQuery.trim() ? 'block' : 'none';
                }
            }

            clearSearch() {
                this.currentSearchQuery = '';
                const searchInput = document.getElementById('groups-search');
                if (searchInput) {
                    searchInput.value = '';
                }
                this.updateClearButton();
                this.filterGroups('');
            }

            initializeSearchState() {
                // Check if we're on the groups page and restore search state
                if (this.currentPage === 'groups') {
                    const searchInput = document.getElementById('groups-search');
                    if (searchInput && this.currentSearchQuery) {
                        searchInput.value = this.currentSearchQuery;
                        this.updateClearButton();
                    }
                }
            }

            renderGroups(groups, searchQuery = '') {
                const content = document.getElementById('groups-content');
                
                if (groups.length === 0) {
                    content.innerHTML = '<div class="alert alert-info">No groups found. Create your first group!</div>';
                    return;
                }

                // Filter groups based on search query
                let filteredGroups = groups;
                if (searchQuery.trim()) {
                    const query = searchQuery.toLowerCase();
                    filteredGroups = groups.filter(group => {
                        // Search in group name
                        if (group.name && group.name.toLowerCase().includes(query)) {
                            return true;
                        }
                        // Search in description
                        if (group.description && group.description.toLowerCase().includes(query)) {
                            return true;
                        }
                        // Search in member names
                        if (group.accounts && group.accounts.some(acc => 
                            acc.name && acc.name.toLowerCase().includes(query)
                        )) {
                            return true;
                        }
                        return false;
                    });
                }

                if (filteredGroups.length === 0) {
                    content.innerHTML = `
                        <div class="alert alert-info">
                            ${searchQuery.trim() ? `No groups found matching "${searchQuery}".` : 'No groups found. Create your first group!'}
                        </div>
                    `;
                    return;
                }

                // Sort groups by priority: Red (offline) first, then Orange, then Blue, then Green
                filteredGroups.sort((a, b) => {
                    const getPriority = (group) => {
                        const totalMembers = group.accounts ? group.accounts.length : 0;
                        if (totalMembers === 0) return 3; // Blue for no members
                        
                        const onlineMembers = group.accounts ? group.accounts.filter(acc => acc.online).length : 0;
                        const offlineMembers = totalMembers - onlineMembers;
                        const onlinePercentage = (onlineMembers / totalMembers) * 100;
                        
                        if (onlinePercentage === 0 || offlineMembers >= totalMembers * 0.5) {
                            return 0; // Red - highest priority
                        } else if (offlineMembers === totalMembers * 0.5) {
                            return 1; // Orange
                        } else if (onlinePercentage === 100) {
                            return 3; // Green - lowest priority
                        } else {
                            return 2; // Blue
                        }
                    };
                    
                    const priorityA = getPriority(a);
                    const priorityB = getPriority(b);
                    
                    if (priorityA !== priorityB) {
                        return priorityA - priorityB; // Lower priority number = higher display priority
                    }
                    
                    // If same priority, sort by name
                    return (a.name || '').localeCompare(b.name || '');
                });

                content.innerHTML = `
                    <div class="row row-cols-1 row-cols-md-2 row-cols-lg-3 g-4">
                        ${filteredGroups.map(group => {
                            // Calculate online/offline status
                            const totalMembers = group.accounts ? group.accounts.length : 0;
                            const onlineMembers = group.accounts ? group.accounts.filter(acc => acc.online).length : 0;
                            const offlineMembers = totalMembers - onlineMembers;
                            
                            // Determine header color based on status
                            let headerClass = 'bg-primary'; // default
                            if (totalMembers > 0) {
                                const onlinePercentage = (onlineMembers / totalMembers) * 100;
                                if (onlinePercentage === 100) {
                                    headerClass = 'bg-success'; // All online - Green
                                } else if (onlinePercentage === 0) {
                                    headerClass = 'bg-danger'; // All offline - Red
                                } else if (offlineMembers >= totalMembers * 0.5) {
                                    headerClass = 'bg-danger'; // >50% offline - Red
                                } else if (offlineMembers === totalMembers * 0.5) {
                                    headerClass = 'bg-warning'; // Exactly 50% offline - Orange
                                } else {
                                    headerClass = 'bg-primary'; // <50% offline - Blue
                                }
                            }
                            
                            return `
                                <div class="col">
                                    <div class="card h-100 shadow-sm">
                                        <div class="card-header ${headerClass} text-white">
                                            <div class="d-flex justify-content-between align-items-center">
                                                <div class="d-flex align-items-center gap-3">
                                                    <h5 class="card-title mb-0">${group.name}</h5>
                                                    <span class="badge ${onlineMembers === 0 ? 'bg-danger' : 'bg-success'}">Online: ${onlineMembers}</span>
                                                    <span class="badge ${offlineMembers === 0 ? 'bg-success' : 'bg-secondary'}">Offline: ${offlineMembers}</span>
                                                    ${typeof group.max_members === 'number' ? `<span class="badge bg-info text-dark">${totalMembers}/${group.max_members}</span>` : `<span class="badge bg-info text-dark">${totalMembers}</span>`}
                                                </div>
                                                <div class="d-flex gap-2">
                                                    <button class="btn btn-sm btn-outline-light" onclick="app.editGroup('${group.id}')">
                                                        <i class="bi bi-pencil"></i>
                                                    </button>
                                                    <button class="btn btn-sm btn-outline-light" onclick="app.deleteGroup('${group.id}')">
                                                        <i class="bi bi-trash"></i>
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="card-body">
                                            ${group.description ? `<p class="card-text text-muted mb-3"><em>${group.description}</em></p>` : ''}
                                            <p class="card-text">
                                                <strong>Members:</strong><br>
                                                <span>
                                                    ${group.accounts && group.accounts.length > 0 
                                                        ? group.accounts.map(acc => `<span class='badge me-1 ${acc.online ? "bg-success" : "bg-danger"}'>${acc.name}</span>`).join(' ')
                                                        : 'No members'
                                                    }
                                                </span>
                                            </p>
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
            }

            transferMembers(fromId, toId) {
                const fromSelect = document.getElementById(fromId);
                const toSelect = document.getElementById(toId);
                
                if (!fromSelect || !toSelect) return;
                
                const selectedOptions = Array.from(fromSelect.selectedOptions);
                if (selectedOptions.length === 0) return; // No items selected
                

                
                // Move selected items to the target list
                selectedOptions.forEach(option => {
                    toSelect.appendChild(option);
                });
                
                // If this is the edit modal, we need to ensure accounts used in other groups don't appear in available
                if (fromId === 'edit-available-accounts' || toId === 'edit-available-accounts') {
                    this.updateEditAvailableList();
                } else {
                    // Update the original options storage to remove transferred items
                    if (fromSelect.dataset.originalOptions) {
                        const originalOptions = JSON.parse(fromSelect.dataset.originalOptions);
                        const transferredValues = selectedOptions.map(opt => opt.value);
                        const remainingOptions = originalOptions.filter(option => 
                            !transferredValues.includes(option.value)
                        );
                        fromSelect.dataset.originalOptions = JSON.stringify(remainingOptions);
                        
                    }
                    
                    // Reapply search filter if there's an active search
                    const searchInput = document.getElementById(fromId.replace('-accounts', '-accounts-search'));
                    if (searchInput && searchInput.value.trim()) {
    
                        this.filterDualList(searchInput.value, fromId);
                    } else {
                        // If no active search, just update the visible options to match the stored original options
                        if (fromSelect.dataset.originalOptions) {
                            const originalOptions = JSON.parse(fromSelect.dataset.originalOptions);
                            fromSelect.innerHTML = '';
                            originalOptions.forEach(option => {
                                const opt = document.createElement('option');
                                opt.value = option.value;
                                opt.textContent = option.text;
                                fromSelect.appendChild(opt);
                            });
    
                        }
                    }
                }
            }

            async loadAvailableAccounts() {
                try {
                    const activeRouter = await this.getActiveRouter();
                    const routerId = activeRouter?.active_router_id;
                    const url = routerId ? `/api/ppp_accounts?router_id=${routerId}` : '/api/ppp_accounts';
                    
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    if (data.success && data.ppp_accounts) {
                        return data.ppp_accounts.map(account => account.name);
                    }
                    return [];
                } catch (error) {
                    console.error('Error loading accounts:', error);
                    return [];
                }
            }

            async populateAddModal() {
                const availableSelect = document.getElementById('available-accounts');
                const selectedSelect = document.getElementById('selected-members');
                
                if (!availableSelect || !selectedSelect) {
                    return;
                }
                
                // Clear existing options and stored data
                availableSelect.innerHTML = '';
                selectedSelect.innerHTML = '';
                delete availableSelect.dataset.originalOptions;
                
                // Load all available accounts
                const allAccounts = await this.loadAvailableAccounts();
                
                // Get all accounts that are already members of existing groups
                const existingGroups = await this.loadExistingGroups();
                const usedAccounts = new Set();
                existingGroups.forEach(group => {
                    if (group.accounts) {
                        group.accounts.forEach(account => usedAccounts.add(account));
                    }
                });
                
                // Populate available accounts (excluding accounts already used in other groups)
                allAccounts.forEach(account => {
                    if (!usedAccounts.has(account)) {
                        const option = document.createElement('option');
                        option.value = account;
                        option.textContent = account;
                        availableSelect.appendChild(option);
                    }
                });
            }

            async loadExistingGroups() {
                try {
                    const activeRouter = await this.getActiveRouter();
                    const routerId = activeRouter?.active_router_id;
                    const url = routerId ? `/api/groups?router_id=${routerId}` : '/api/groups';
                    
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    if (data.success && data.groups) {
                        return data.groups;
                    }
                    return [];
                } catch (error) {
                    console.error('Error loading existing groups:', error);
                    return [];
                }
            }

            async updateEditAvailableList() {
                const availableSelect = document.getElementById('edit-available-accounts');
                const selectedSelect = document.getElementById('edit-selected-members');
                
                if (!availableSelect || !selectedSelect) return;
                
                // Get current selected members
                const currentSelectedMembers = Array.from(selectedSelect.options).map(opt => opt.value);
                
                // Load all available accounts
                const allAccounts = await this.loadAvailableAccounts();
                
                // Get all accounts that are already members of existing groups
                const existingGroups = await this.loadExistingGroups();
                const usedAccounts = new Set();
                existingGroups.forEach(group => {
                    if (group.accounts) {
                        group.accounts.forEach(account => usedAccounts.add(account));
                    }
                });
                
                // Remove current group's accounts from used accounts (so they can be re-selected)
                const currentGroupId = document.getElementById('edit-group-id')?.value;
                if (currentGroupId) {
                    const currentGroup = existingGroups.find(g => g.id === currentGroupId);
                    if (currentGroup && currentGroup.accounts) {
                        currentGroup.accounts.forEach(account => usedAccounts.delete(account));
                    }
                }
                
                // Clear and repopulate available list
                availableSelect.innerHTML = '';
                
                // Populate available accounts (excluding accounts used in other groups and already selected ones)
                const availableOptions = [];
                allAccounts.forEach(account => {
                    if (!usedAccounts.has(account) && !currentSelectedMembers.includes(account)) {
                        const option = document.createElement('option');
                        option.value = account;
                        option.textContent = account;
                        availableSelect.appendChild(option);
                        availableOptions.push({ value: account, text: account });
                    }
                });
                
                // Store original options for search functionality
                availableSelect.dataset.originalOptions = JSON.stringify(availableOptions);
            }

            async populateDualList(availableSelectId, selectedSelectId, selectedAccounts = []) {
                const availableSelect = document.getElementById(availableSelectId);
                const selectedSelect = document.getElementById(selectedSelectId);
                
                if (!availableSelect || !selectedSelect) {
                    return;
                }
                
                // Clear existing options and stored data
                availableSelect.innerHTML = '';
                selectedSelect.innerHTML = '';
                delete availableSelect.dataset.originalOptions;
                
                // Load all available accounts
                const allAccounts = await this.loadAvailableAccounts();
                
                // Get all accounts that are already members of existing groups
                const existingGroups = await this.loadExistingGroups();
                const usedAccounts = new Set();
                existingGroups.forEach(group => {
                    if (group.accounts) {
                        group.accounts.forEach(account => usedAccounts.add(account));
                    }
                });
                
                // Remove current group's accounts from used accounts (so they can be re-selected)
                const currentGroupId = document.getElementById('edit-group-id')?.value;
                if (currentGroupId) {
                    const currentGroup = existingGroups.find(g => g.id === currentGroupId);
                    if (currentGroup && currentGroup.accounts) {
                        currentGroup.accounts.forEach(account => usedAccounts.delete(account));
                    }
                }
                
                // Populate available accounts (excluding accounts used in other groups and already selected ones)
                const availableOptions = [];
                allAccounts.forEach(account => {
                    if (!usedAccounts.has(account) && !selectedAccounts.includes(account)) {
                        const option = document.createElement('option');
                        option.value = account;
                        option.textContent = account;
                        availableSelect.appendChild(option);
                        availableOptions.push({ value: account, text: account });
                    }
                });
                
                // Store original options for search functionality
                availableSelect.dataset.originalOptions = JSON.stringify(availableOptions);
                
                // Populate selected accounts
                selectedAccounts.forEach(account => {
                    const option = document.createElement('option');
                    option.value = account;
                    option.textContent = account;
                    selectedSelect.appendChild(option);
                });
            }

            getSelectedMembers(selectedSelectId) {
                const selectedSelect = document.getElementById(selectedSelectId);
                if (!selectedSelect) return [];
                
                return Array.from(selectedSelect.options).map(option => option.value);
            }

            async saveGroup() {
                const name = document.getElementById('group-name').value.trim();
                const description = document.getElementById('group-description').value.trim();
                const maxMembersStr = document.getElementById('group-max-members').value.trim();
                const max_members = maxMembersStr ? parseInt(maxMembersStr) : undefined;
                const selectedMembers = this.getSelectedMembers('selected-members');
                if (!name) {
                    showError('Validation Error', 'Group name is required');
                    return;
                }
                try {
                    const activeRouter = await this.getActiveRouter();
                    const routerId = activeRouter?.active_router_id;
                    const payload = {
                        name,
                        description,
                        accounts: selectedMembers,
                        router_id: routerId
                    };
                    if (max_members) payload.max_members = max_members;
                    const response = await fetch('/api/groups', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(payload)
                    });
                    const data = await response.json();
                    if (data.success) {
                        showSuccess('Group Created', 'Group saved successfully');
                        document.getElementById('group-name').value = '';
                        document.getElementById('group-description').value = '';
                        document.getElementById('group-max-members').value = '';
                        document.getElementById('selected-members').innerHTML = '';
                        document.getElementById('available-accounts').innerHTML = '';
                        bootstrap.Modal.getInstance(document.getElementById('addGroupModal')).hide();
                        this.loadGroups();
                    } else {
                        showError('Save Error', data.error || 'Failed to save group');
                    }
                } catch (error) {
                    console.error('Error saving group:', error);
                    showError('Save Error', 'Failed to save group');
                }
            }

            async editGroup(groupId) {
                // Load group data and populate edit modal
                try {
                    const response = await fetch('/api/groups');
                    const data = await response.json();
                    
                    if (data.success) {
                        const group = data.groups.find(g => g.id === groupId);
                        if (group) {
                            document.getElementById('edit-group-id').value = group.id;
                            document.getElementById('edit-group-name').value = group.name;
                            document.getElementById('edit-group-description').value = group.description || '';
                            document.getElementById('edit-group-max-members').value = group.max_members || '';
                            
                            // Populate dual list with current group members
                            await this.populateDualList(
                                'edit-available-accounts', 
                                'edit-selected-members', 
                                group.accounts || []
                            );
                            
                            const modal = new bootstrap.Modal(document.getElementById('editGroupModal'));
                            modal.show();
                        }
                    }
                } catch (error) {
                    console.error('Error loading group for edit:', error);
                    showError('Edit Error', 'Failed to load group data');
                }
            }

            async updateGroup() {
                const id = document.getElementById('edit-group-id').value;
                const name = document.getElementById('edit-group-name').value.trim();
                const description = document.getElementById('edit-group-description').value.trim();
                const maxMembersStr = document.getElementById('edit-group-max-members').value.trim();
                const max_members = maxMembersStr ? parseInt(maxMembersStr) : undefined;
                const selectedMembers = this.getSelectedMembers('edit-selected-members');
                if (!name) {
                    showError('Validation Error', 'Group name is required');
                    return;
                }
                try {
                    const activeRouter = await this.getActiveRouter();
                    const routerId = activeRouter?.active_router_id;
                    const payload = {
                        id,
                        name,
                        description,
                        accounts: selectedMembers,
                        router_id: routerId
                    };
                    if (max_members) payload.max_members = max_members;
                    const response = await fetch('/api/groups', {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(payload)
                    });
                    const data = await response.json();
                    if (data.success) {
                        showSuccess('Group Updated', 'Group updated successfully');
                        bootstrap.Modal.getInstance(document.getElementById('editGroupModal')).hide();
                        this.loadGroups();
                    } else {
                        showError('Update Error', data.error || 'Failed to update group');
                    }
                } catch (error) {
                    console.error('Error updating group:', error);
                    showError('Update Error', 'Failed to update group');
                }
            }

            async deleteGroup(groupId) {
                if (!confirm('Are you sure you want to delete this group?')) {
                    return;
                }

                try {
                    const activeRouter = await this.getActiveRouter();
                    const routerId = activeRouter?.active_router_id;
                    const url = routerId ? `/api/groups?id=${groupId}&router_id=${routerId}` : `/api/groups?id=${groupId}`;
                    
                    const response = await fetch(url, {
                        method: 'DELETE'
                    });

                    const data = await response.json();
                    
                    if (data.success) {
                        showSuccess('Group Deleted', 'Group deleted successfully');
                        this.loadGroups();
                    } else {
                        showError('Delete Error', data.error || 'Failed to delete group');
                    }
                } catch (error) {
                    console.error('Error deleting group:', error);
                    showError('Delete Error', 'Failed to delete group');
                }
            }

            async loadSettings() {
                try {
                    const response = await fetch('/api/settings');
                    const data = await response.json();
                    
                    if (data.success) {
                        document.getElementById('router_ip').value = data.router_ip || '';
                        document.getElementById('router_port').value = data.router_port || 8728;
                        document.getElementById('router_user').value = data.router_user || '';
                        document.getElementById('router_password').value = '';
                    } else {
                        showError('Settings Error', data.error || 'Failed to load settings');
                    }
                } catch (error) {
                    console.error('Error loading settings:', error);
                    showError('Settings Error', 'Failed to load settings');
                }
            }

            async saveSettings() {
                const formData = new FormData(document.getElementById('settings-form'));
                const settings = {
                    router_ip: formData.get('router_ip'),
                    router_port: parseInt(formData.get('router_port')),
                    router_user: formData.get('router_user'),
                    router_password: formData.get('router_password')
                };

                try {
                    const response = await fetch('/api/settings', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(settings)
                    });

                    const data = await response.json();
                    
                    if (data.success) {
                        showSuccess('Settings Saved', 'Settings updated successfully');
                    } else {
                        showError('Save Error', data.error || 'Failed to save settings');
                    }
                } catch (error) {
                    console.error('Error saving settings:', error);
                    showError('Save Error', 'Failed to save settings');
                }
            }

            async testConnection() {
                try {
                    const response = await fetch('/api/status');
                    const data = await response.json();
                    
                    if (data.success && data.connected) {
                        showSuccess('Connection Test', 'Successfully connected to router');
                    } else {
                        showError('Connection Test', 'Failed to connect to router');
                    }
                } catch (error) {
                    console.error('Error testing connection:', error);
                    showError('Connection Test', 'Failed to test connection');
                }
            }

            setRefreshInterval(seconds) {
                if (this.refreshInterval) {
                    clearInterval(this.refreshInterval);
                    this.refreshInterval = null;
                }
                
                const display = document.getElementById('refresh-interval-display');
                display.textContent = seconds > 0 ? seconds + ' seconds' : 'Off';
                
                if (seconds > 0) {
                    this.refreshInterval = setInterval(() => {
                        if (this.currentPage === 'dashboard') {
                            this.refreshDashboardData();
                        } else if (this.currentPage === 'groups') {
                            this.loadGroups();
                        }
                    }, seconds * 1000);
                }
                
                localStorage.setItem('refreshInterval', seconds.toString());
            }

            updateFooter() {
                const now = new Date().toLocaleString();
                document.getElementById('footer-time').textContent = now;
                document.getElementById('last-updated-time').textContent = now;
            }

            formatMbps(bps, decimals = 2) {
                if (!bps || bps <= 0) return '0 Mbps';
                return (bps * 8 / 1_000_000).toFixed(decimals) + ' Mbps';
            }

            // Helper to convert IP address to a number for sorting
            ipToNumber(ip) {
                if (!ip) return 0;
                return ip.split('.').reduce((acc, octet) => (acc << 8) + parseInt(octet, 10), 0);
            }

            // Helper to parse uptime string (e.g., '4d4h30m5s') to seconds
            uptimeToSeconds(uptime) {
                if (!uptime) return 0;
                let total = 0;
                const regex = /(?:(\d+)d)?(?:(\d+)h)?(?:(\d+)m)?(?:(\d+)s)?/;
                const match = uptime.match(regex);
                if (match) {
                    total += (parseInt(match[1] || 0, 10) * 86400); // days
                    total += (parseInt(match[2] || 0, 10) * 3600);  // hours
                    total += (parseInt(match[3] || 0, 10) * 60);    // minutes
                    total += (parseInt(match[4] || 0, 10));         // seconds
                }
                return total;
            }

            filterPPPoETable(query) {
                const tbody = document.querySelector('#pppoe-interfaces-table tbody');
                if (!tbody) return;
                const rows = Array.from(tbody.querySelectorAll('tr'));
                const q = query.trim().toLowerCase();
                rows.forEach(row => {
                    const text = row.textContent.toLowerCase();
                    row.style.display = text.includes(q) ? '' : 'none';
                });
            }

            filterDualList(query, availableSelectId) {
                const availableSelect = document.getElementById(availableSelectId);
                if (!availableSelect) return;



                // Store original options if not already stored
                if (!availableSelect.dataset.originalOptions) {
                    availableSelect.dataset.originalOptions = JSON.stringify(
                        Array.from(availableSelect.options).map(opt => ({
                            value: opt.value,
                            text: opt.textContent
                        }))
                    );

                }

                // Get original options
                const originalOptions = JSON.parse(availableSelect.dataset.originalOptions);
                
                // Filter based on search query
                const filteredOptions = originalOptions.filter(option => 
                    option.text.toLowerCase().includes(query.toLowerCase())
                );

                // Clear and repopulate
                availableSelect.innerHTML = '';
                filteredOptions.forEach(option => {
                    const opt = document.createElement('option');
                    opt.value = option.value;
                    opt.textContent = option.text;
                    availableSelect.appendChild(opt);
                });
            }

            // Router Management Methods
            async loadRouters() {
                try {
                    const response = await fetch('/api/routers');
                    const data = await response.json();
                    
                    if (data.success) {
                        this.populateRouterSelector(data.routers);
                        this.populateRoutersTable(data.routers);
                    } else {
                        showError('Routers Error', data.error || 'Failed to load routers');
                    }
                } catch (error) {
                    console.error('Error loading routers:', error);
                    showError('Routers Error', 'Failed to load routers');
                }
            }

            populateRouterSelector(routers) {
                const selector = document.getElementById('router-selector');
                if (!selector) return;

                this.initializingRouters = true; // Set flag before changing value

                selector.innerHTML = '';
                routers.forEach(router => {
                    const option = document.createElement('option');
                    option.value = router.id;
                    option.textContent = router.name;
                    selector.appendChild(option);
                });

                // Set active router
                this.getActiveRouter().then(activeRouter => {
                    if (activeRouter && activeRouter.active_router_id) {
                        selector.value = activeRouter.active_router_id;
                    } else if (routers.length > 0) {
                        selector.value = routers[0].id;
                    }
                    this.initializingRouters = false; // Unset flag after done
                });
            }

            populateRoutersTable(routers) {
                const tbody = document.querySelector('#routers-table tbody');
                if (!tbody) return;

                tbody.innerHTML = '';
                routers.forEach(router => {
                    const row = document.createElement('tr');
                    const statusClass = router.connection_status === 'connected' ? 'text-success' : 
                                     router.connection_status === 'disconnected' ? 'text-danger' : 'text-warning';
                    const statusIcon = router.connection_status === 'connected' ? 'bi-wifi' : 
                                    router.connection_status === 'disconnected' ? 'bi-wifi-off' : 'bi-question-circle';
                    
                    row.innerHTML = `
                        <td>${router.name}</td>
                        <td>${router.host}</td>
                        <td><i class="bi ${statusIcon} ${statusClass}"></i> ${router.connection_status}</td>
                        <td>${router.last_connection ? new Date(router.last_connection).toLocaleString() : 'Never'}</td>
                        <td>
                            <div class="btn-group btn-group-sm">
                                <button class="btn btn-outline-primary" onclick="app.testRouterConnection('${router.id}')">
                                    <i class="bi bi-wifi"></i> Test
                                </button>
                                <button class="btn btn-outline-secondary" onclick="app.editRouter('${router.id}')">
                                    <i class="bi bi-pencil"></i> Edit
                                </button>
                                <button class="btn btn-outline-danger" onclick="app.deleteRouter('${router.id}')">
                                    <i class="bi bi-trash"></i> Delete
                                </button>
                            </div>
                        </td>
                    `;
                    tbody.appendChild(row);
                });
            }

            async getActiveRouter() {
                try {
                    const response = await fetch('/api/routers/active');
                    return await response.json();
                } catch (error) {
                    console.error('Error getting active router:', error);
                    return null;
                }
            }

            async switchRouter(routerId) {
                if (!routerId) return;

                try {
                    const response = await fetch('/api/routers/active', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ router_id: routerId })
                    });

                    const data = await response.json();
                    
                    if (data.success) {
                        showSuccess('Router Switched', `Switched to ${data.router_name}`);
                        // Refresh current page data
                        this.loadCurrentPage();
                    } else {
                        showError('Switch Error', data.error || 'Failed to switch router');
                    }
                } catch (error) {
                    console.error('Error switching router:', error);
                    showError('Switch Error', 'Failed to switch router');
                }
            }

            showAddRouterModal() {
                // Clear form
                document.getElementById('add-router-form').reset();
                // Show modal
                const modal = new bootstrap.Modal(document.getElementById('addRouterModal'));
                modal.show();
            }

            async saveRouter() {
                const form = document.getElementById('add-router-form');
                const formData = new FormData(form);
                
                const routerData = {
                    name: formData.get('router-name'),
                    description: formData.get('router-description'),
                    host: formData.get('router-host'),
                    port: parseInt(formData.get('router-port')),
                    username: formData.get('router-username'),
                    password: formData.get('router-password'),
                    use_ssl: document.getElementById('router-ssl').checked
                };

                try {
                    const response = await fetch('/api/routers', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(routerData)
                    });

                    const data = await response.json();
                    
                    if (data.success) {
                        showSuccess('Router Added', 'Router added successfully');
                        bootstrap.Modal.getInstance(document.getElementById('addRouterModal')).hide();
                        this.loadRouters();
                    } else {
                        showError('Add Error', data.error || 'Failed to add router');
                    }
                } catch (error) {
                    console.error('Error adding router:', error);
                    showError('Add Error', 'Failed to add router');
                }
            }

            async editRouter(routerId) {
                try {
                    const response = await fetch(`/api/routers/${routerId}`);
                    const data = await response.json();
                    
                    if (data.success) {
                        const router = data.router;
    
                        if (router) {
                            this.populateEditRouterForm(router);
                            const modal = new bootstrap.Modal(document.getElementById('editRouterModal'));
                            modal.show();
                        }
                    }
                } catch (error) {
                    console.error('Error loading router for edit:', error);
                    showError('Edit Error', 'Failed to load router data');
                }
            }

            populateEditRouterForm(router) {
                document.getElementById('edit-router-id').value = router.id || '';
                document.getElementById('edit-router-name').value = router.name || '';
                document.getElementById('edit-router-description').value = router.description || '';
                document.getElementById('edit-router-host').value = router.host || '';
                document.getElementById('edit-router-port').value = router.port !== undefined ? router.port : '';
                document.getElementById('edit-router-username').value = router.username || '';
                document.getElementById('edit-router-password').value = '';
                document.getElementById('edit-router-ssl').checked = router.use_ssl || false;
            }

            async updateRouter() {
                const form = document.getElementById('edit-router-form');
                const formData = new FormData(form);
                
                const routerData = {
                    id: formData.get('edit-router-id'),
                    name: formData.get('edit-router-name'),
                    description: formData.get('edit-router-description'),
                    host: formData.get('edit-router-host'),
                    port: parseInt(formData.get('edit-router-port')),
                    username: formData.get('edit-router-username'),
                    password: formData.get('edit-router-password'),
                    use_ssl: document.getElementById('edit-router-ssl').checked
                };

                // Debug: Log all routerData fields before validation
                
                if (!routerData.id || !routerData.name || !routerData.host || isNaN(routerData.port) || !routerData.username) {
                    showError('Validation Error', 'All fields except password and description are required.');
                    return;
                }

                try {
                    const response = await fetch('/api/routers', {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(routerData)
                    });

                    const data = await response.json();
                    
                    if (data.success) {
                        showSuccess('Router Updated', 'Router updated successfully');
                        bootstrap.Modal.getInstance(document.getElementById('editRouterModal')).hide();
                        this.loadRouters();
                    } else {
                        showError('Update Error', data.error || 'Failed to update router');
                    }
                } catch (error) {
                    console.error('Error updating router:', error);
                    showError('Update Error', 'Failed to update router');
                }
            }

            async deleteRouter(routerId) {
                if (!confirm('Are you sure you want to delete this router? This will also delete all associated groups.')) {
                    return;
                }

                try {
                    const response = await fetch(`/api/routers?id=${routerId}`, {
                        method: 'DELETE'
                    });

                    const data = await response.json();
                    
                    if (data.success) {
                        showSuccess('Router Deleted', 'Router deleted successfully');
                        this.loadRouters();
                    } else {
                        showError('Delete Error', data.error || 'Failed to delete router');
                    }
                } catch (error) {
                    console.error('Error deleting router:', error);
                    showError('Delete Error', 'Failed to delete router');
                }
            }

            async testRouterConnection(routerId) {
                try {
                    const response = await fetch('/api/routers/test', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ router_id: routerId })
                    });

                    const data = await response.json();
                    
                    if (data.success && data.connected) {
                        showSuccess('Connection Test', `Successfully connected to ${data.router_name}`);
                    } else {
                        showError('Connection Test', data.error || 'Failed to connect to router');
                    }
                } catch (error) {
                    console.error('Error testing router connection:', error);
                    showError('Connection Test', 'Failed to test connection');
                }
            }

            // Add the new method to the class
            async loadCategoriesForSummary() {
                const summaryContainer = document.querySelector('#groups-summary-page .container-fluid');
                if (!summaryContainer) return;
                // Clear all content before rendering
                summaryContainer.innerHTML = '';
                // Add title
                const title = document.createElement('h2');
                title.textContent = 'Groups Summary';
                // Add 'Add Category' button
                const addCatBtn = document.createElement('button');
                addCatBtn.className = 'btn btn-sm btn-outline-primary float-end mb-3';
                addCatBtn.innerHTML = `<i class="bi bi-plus-circle"></i> Add Category`;
                addCatBtn.style.background = 'transparent';
                addCatBtn.onclick = () => this.showCategoryModal();
                // Always show header row (title + button)
                const headerRow = document.createElement('div');
                headerRow.className = 'd-flex justify-content-between align-items-center mb-3';
                headerRow.appendChild(title);
                headerRow.appendChild(addCatBtn);
                summaryContainer.appendChild(headerRow);
                const activeRouter = await this.getActiveRouter();
                const routerId = activeRouter?.active_router_id;
                if (!routerId) {
                    const info = document.createElement('div');
                    info.className = 'alert alert-warning';
                    info.textContent = 'No router selected.';
                    summaryContainer.appendChild(info);
                    return;
                }
                // Fetch groups for this router so we can map group IDs to names
                let groupsList = [];
                try {
                    const groupsResp = await fetch(`/api/groups?router_id=${routerId}`);
                    const groupsData = await groupsResp.json();
                    if (groupsData.success && Array.isArray(groupsData.groups)) {
                        groupsList = groupsData.groups;
                        this.groupsData = groupsList;
                    } else {
                        this.groupsData = [];
                    }
                } catch (e) {
                    this.groupsData = [];
                }
                try {
                    const response = await fetch(`/api/categories?router_id=${routerId}`);
                    const data = await response.json();
                    if (!data.success) {
                        const info = document.createElement('div');
                        info.className = 'alert alert-danger';
                        info.textContent = `Failed to load categories: ${data.error || 'Unknown error'}`;
                        summaryContainer.appendChild(info);
                        return;
                    }
                    const categories = data.categories || [];
                    this._lastCategories = categories;
                    if (categories.length === 0) {
                        const info = document.createElement('div');
                        info.className = 'alert alert-info';
                        info.textContent = 'No categories found for this router.';
                        summaryContainer.appendChild(info);
                        return;
                    }
                    const list = document.createElement('div');
                    list.className = 'categories-list';
                    categories.forEach((cat, catIdx) => {
                        // Calculate total members and max_members for the whole category
                        let catTotalMembers = 0;
                        let catTotalMax = 0;
                        let catHasAllMax = true;
                        if (Array.isArray(cat.subcategories)) {
                            cat.subcategories.forEach(sub => {
                                if (Array.isArray(sub.groups) && Array.isArray(this.groupsData)) {
                                    sub.groups.forEach(gid => {
                                        const g = this.groupsData.find(gr => gr.id === gid);
                                        if (g) {
                                            catTotalMembers += g.accounts ? g.accounts.length : 0;
                                            if (typeof g.max_members === 'number') {
                                                catTotalMax += g.max_members;
                                            } else {
                                                catHasAllMax = false;
                                            }
                                        }
                                    });
                                }
                            });
                        }
                        let catCountStr = '';
                        if (catTotalMembers > 0) {
                            if (catHasAllMax && catTotalMax > 0) {
                                const catVacant = catTotalMax - catTotalMembers;
                                catCountStr = ` <span class='badge bg-primary ms-2'>members: ${catTotalMembers}/${catTotalMax}, vacant: ${catVacant}</span>`;
                            } else {
                                catCountStr = ` <span class='badge bg-primary ms-2'>members: ${catTotalMembers}</span>`;
                            }
                        }
                        const catDiv = document.createElement('div');
                        catDiv.className = 'category-card card mb-3';
                        catDiv.innerHTML = `<div class='card-header d-flex justify-content-between align-items-center fw-bold'>
                            <span>${cat.category}${catCountStr}</span>
                            <span>
                                <button class='btn btn-sm btn-outline-success me-1' style='background:transparent;' title='Add Subcategory' onclick='app.showSubcategoryModal(${catIdx})'><i class=\"bi bi-plus\"></i></button>
                                <button class='btn btn-sm btn-outline-secondary me-1' style='background:transparent;' title='Edit Category' onclick='app.showCategoryModal(${catIdx})'><i class=\"bi bi-pencil\"></i></button>
                                <button class='btn btn-sm btn-outline-danger' style='background:transparent;' title='Delete Category' onclick='app.deleteCategory(${catIdx})'><i class=\"bi bi-trash\"></i></button>
                            </span>
                        </div>`;
                        if (Array.isArray(cat.subcategories) && cat.subcategories.length > 0) {
                            const subList = document.createElement('ul');
                            subList.className = 'list-group list-group-flush';
                            cat.subcategories.forEach((sub, subIdx) => {
                                const subItem = document.createElement('li');
                                subItem.className = 'list-group-item d-flex flex-column ms-4'; // Add ms-4 for left indent
                                // Subcategory name row
                                const subRow = document.createElement('div');
                                subRow.className = 'd-flex justify-content-between align-items-center';
                                // Calculate total members and max_members for this subcategory
                                let subTotalMembers = 0;
                                let subTotalMax = 0;
                                let hasAllMax = true;
                                if (Array.isArray(sub.groups) && sub.groups.length > 0 && Array.isArray(this.groupsData)) {
                                    sub.groups.forEach(gid => {
                                        const g = this.groupsData.find(gr => gr.id === gid);
                                        if (g) {
                                            subTotalMembers += g.accounts ? g.accounts.length : 0;
                                            if (typeof g.max_members === 'number') {
                                                subTotalMax += g.max_members;
                                            } else {
                                                hasAllMax = false;
                                            }
                                        }
                                    });
                                }
                                let subcatCountStr = '';
                                if (sub.groups && sub.groups.length > 0) {
                                    if (hasAllMax && subTotalMax > 0) {
                                        const vacant = subTotalMax - subTotalMembers;
                                        subcatCountStr = ` <span class='badge bg-primary ms-2'>members: ${subTotalMembers}/${subTotalMax}, vacant: ${vacant}</span>`;
                                    } else {
                                        subcatCountStr = ` <span class='badge bg-primary ms-2'>members: ${subTotalMembers}</span>`;
                                    }
                                }
                                subRow.innerHTML = `<span>${sub.subcategory}${subcatCountStr}</span>
                                    <span>
                                        <button class='btn btn-sm btn-outline-primary me-1' style='background:transparent;' title='Assign Groups' onclick='app.showAssignGroupsModal(${catIdx},${subIdx})'><i class=\"bi bi-collection\"></i></button>
                                        <button class='btn btn-sm btn-outline-secondary me-1' style='background:transparent;' title='Edit Subcategory' onclick='app.showSubcategoryModal(${catIdx},${subIdx})'><i class=\"bi bi-pencil\"></i></button>
                                        <button class='btn btn-sm btn-outline-danger' style='background:transparent;' title='Delete Subcategory' onclick='app.deleteSubcategory(${catIdx},${subIdx})'><i class=\"bi bi-trash\"></i></button>
                                    </span>`;
                                subItem.appendChild(subRow);
                                // Assigned groups row
                                const assignedGroups = Array.isArray(sub.groups) && sub.groups.length > 0 ? sub.groups : [];
                                const assignedGroupsDiv = document.createElement('div');
                                assignedGroupsDiv.className = 'mt-2';
                                if (assignedGroups.length > 0) {
                                    assignedGroupsDiv.innerHTML = `<strong>Groups:</strong> ` + assignedGroups.map(gid => {
                                        const g = this.groupsData.find(gr => gr.id === gid);
                                        if (g) {
                                            const total = g.accounts ? g.accounts.length : 0;
                                            return `<span class='badge bg-info text-dark me-1'>${g.name} (${total}${typeof g.max_members === 'number' ? `/${g.max_members}` : ''})</span>`;
                                        } else {
                                            return `<span class='badge bg-info text-dark me-1'>${gid}</span>`;
                                        }
                                    }).join(' ');
                                } else {
                                    assignedGroupsDiv.innerHTML = `<span class='text-muted'><em>No groups assigned</em></span>`;
                                }
                                subItem.appendChild(assignedGroupsDiv);
                                subList.appendChild(subItem);
                            });
                            catDiv.appendChild(subList);
                        } else {
                            catDiv.innerHTML += `<div class='card-body text-muted'>No subcategories</div>`;
                        }
                        list.appendChild(catDiv);
                    });
                    summaryContainer.appendChild(list);
                } catch (err) {
                    const info = document.createElement('div');
                    info.className = 'alert alert-danger';
                    info.textContent = 'Error loading categories.';
                    summaryContainer.appendChild(info);
                }
            }

            // Add modal HTML for add/edit category and subcategory
            injectCategoryModals() {
                if (document.getElementById('categoryModal')) return; // Only inject once
                const modalHtml = `
                <div class="modal fade" id="categoryModal" tabindex="-1" aria-labelledby="categoryModalLabel" aria-hidden="true">
                  <div class="modal-dialog">
                    <div class="modal-content">
                      <div class="modal-header">
                        <h5 class="modal-title" id="categoryModalLabel">Category</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                      </div>
                      <div class="modal-body">
                        <input type="text" class="form-control" id="categoryNameInput" placeholder="Category name">
                      </div>
                      <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-primary" id="saveCategoryBtn">Save</button>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="modal fade" id="subcategoryModal" tabindex="-1" aria-labelledby="subcategoryModalLabel" aria-hidden="true">
                  <div class="modal-dialog">
                    <div class="modal-content">
                      <div class="modal-header">
                        <h5 class="modal-title" id="subcategoryModalLabel">Subcategory</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                      </div>
                      <div class="modal-body">
                        <input type="text" class="form-control" id="subcategoryNameInput" placeholder="Subcategory name">
                      </div>
                      <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-primary" id="saveSubcategoryBtn">Save</button>
                      </div>
                    </div>
                  </div>
                </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHtml);
            }

            showCategoryModal(catIdx = null) {
                console.log('showCategoryModal called', { catIdx, lastCategories: this._lastCategories });
                this._categoryEditIndex = catIdx;
                const modal = new bootstrap.Modal(document.getElementById('categoryModal'));
                const input = document.getElementById('categoryNameInput');
                if (catIdx !== null && this._lastCategories && this._lastCategories[catIdx]) {
                    input.value = this._lastCategories[catIdx].category;
                    document.getElementById('categoryModalLabel').textContent = 'Edit Category';
                } else {
                    input.value = '';
                    document.getElementById('categoryModalLabel').textContent = 'Add Category';
                }
                document.getElementById('saveCategoryBtn').onclick = () => this.saveCategory();
                modal.show();
            }

            showSubcategoryModal(catIdx, subIdx = null) {
                this._subcategoryEditCatIdx = catIdx;
                this._subcategoryEditIdx = subIdx;
                const modal = new bootstrap.Modal(document.getElementById('subcategoryModal'));
                const input = document.getElementById('subcategoryNameInput');
                if (
                    subIdx !== null &&
                    this._lastCategories &&
                    this._lastCategories[catIdx] &&
                    this._lastCategories[catIdx].subcategories &&
                    this._lastCategories[catIdx].subcategories[subIdx]
                ) {
                    input.value = this._lastCategories[catIdx].subcategories[subIdx].subcategory;
                    document.getElementById('subcategoryModalLabel').textContent = 'Edit Subcategory';
                } else {
                    input.value = '';
                    document.getElementById('subcategoryModalLabel').textContent = 'Add Subcategory';
                }
                document.getElementById('saveSubcategoryBtn').onclick = () => this.saveSubcategory();
                modal.show();
            }

            deleteCategory(catIdx) {
                if (!confirm('Delete this category and all its subcategories?')) return;
                if (!this._lastCategories) return;
                this._lastCategories.splice(catIdx, 1);
                this.saveCategoriesToServer();
            }

            deleteSubcategory(catIdx, subIdx) {
                if (!confirm('Delete this subcategory?')) return;
                if (!this._lastCategories || !this._lastCategories[catIdx] || !this._lastCategories[catIdx].subcategories) return;
                this._lastCategories[catIdx].subcategories.splice(subIdx, 1);
                this.saveCategoriesToServer();
            }

            saveCategory() {
                const input = document.getElementById('categoryNameInput');
                const name = input.value.trim();
                if (!name) return alert('Category name required');
                if (!this._lastCategories) this._lastCategories = [];
                if (this._categoryEditIndex !== null && this._lastCategories[this._categoryEditIndex]) {
                    this._lastCategories[this._categoryEditIndex].category = name;
                } else {
                    this._lastCategories.push({ category: name, subcategories: [] });
                }
                bootstrap.Modal.getInstance(document.getElementById('categoryModal')).hide();
                this.saveCategoriesToServer();
            }

            saveSubcategory() {
                const input = document.getElementById('subcategoryNameInput');
                const name = input.value.trim();
                if (!name) return alert('Subcategory name required');
                if (!this._lastCategories || this._subcategoryEditCatIdx == null) return;
                const cat = this._lastCategories[this._subcategoryEditCatIdx];
                if (!cat.subcategories) cat.subcategories = [];
                if (this._subcategoryEditIdx !== null && cat.subcategories[this._subcategoryEditIdx]) {
                    cat.subcategories[this._subcategoryEditIdx].subcategory = name;
                } else {
                    cat.subcategories.push({ subcategory: name, groups: [] });
                }
                bootstrap.Modal.getInstance(document.getElementById('subcategoryModal')).hide();
                this.saveCategoriesToServer();
            }

            async saveCategoriesToServer() {
                // Save to server and reload UI
                const activeRouter = await this.getActiveRouter();
                const routerId = activeRouter?.active_router_id;
                if (!routerId) return;
                try {
                    const res = await fetch('/api/categories', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ router_id: routerId, categories: this._lastCategories })
                    });
                    const data = await res.json();
                    if (data.success) {
                        this.loadCategoriesForSummary();
                    } else {
                        alert('Failed to save categories: ' + (data.error || 'Unknown error'));
                    }
                } catch (err) {
                    alert('Error saving categories');
                }
            }

            showAssignGroupsModal(catIdx, subIdx) {
                this._assignGroupsCatIdx = catIdx;
                this._assignGroupsSubIdx = subIdx;
                const modal = new bootstrap.Modal(document.getElementById('assignGroupsModal'));
                const availableSelect = document.getElementById('assign-available-groups');
                const selectedSelect = document.getElementById('assign-selected-groups');
                availableSelect.innerHTML = '<option>Loading...</option>';
                selectedSelect.innerHTML = '';
                // Fetch groups for the current router
                this.getActiveRouter().then(activeRouter => {
                    const routerId = activeRouter?.active_router_id;
                    if (!routerId) return;
                    fetch(`/api/groups?router_id=${routerId}`)
                        .then(res => res.json())
                        .then(data => {
                            availableSelect.innerHTML = '';
                            selectedSelect.innerHTML = '';
                            if (!data.success || !Array.isArray(data.groups)) {
                                availableSelect.innerHTML = '<option disabled>Error loading groups</option>';
                                return;
                            }
                            const assigned = (this._lastCategories?.[catIdx]?.subcategories?.[subIdx]?.groups) || [];
                            // Collect all group IDs assigned to any subcategory (except the current one)
                            let allAssigned = new Set();
                            if (this._lastCategories && this._lastCategories[catIdx] && Array.isArray(this._lastCategories[catIdx].subcategories)) {
                                this._lastCategories[catIdx].subcategories.forEach((sub, sidx) => {
                                    if (sidx !== subIdx && Array.isArray(sub.groups)) {
                                        sub.groups.forEach(gid => allAssigned.add(gid));
                                    }
                                });
                            }
                            // Populate assigned groups (right)
                            data.groups.forEach(group => {
                                if (assigned.includes(group.id)) {
                                    const opt = document.createElement('option');
                                    opt.value = group.id;
                                    opt.textContent = group.name;
                                    selectedSelect.appendChild(opt);
                                }
                            });
                            // Populate available groups (left), exclude those assigned to other subcategories
                            data.groups.forEach(group => {
                                if (!assigned.includes(group.id) && !allAssigned.has(group.id)) {
                                    const opt = document.createElement('option');
                                    opt.value = group.id;
                                    opt.textContent = group.name;
                                    availableSelect.appendChild(opt);
                                }
                            });
                        });
                });
                // Transfer logic
                document.getElementById('assign-add-groups').onclick = () => {
                    const selected = Array.from(availableSelect.selectedOptions);
                    selected.forEach(opt => {
                        selectedSelect.appendChild(opt);
                    });
                };
                document.getElementById('assign-remove-groups').onclick = () => {
                    const selected = Array.from(selectedSelect.selectedOptions);
                    selected.forEach(opt => {
                        availableSelect.appendChild(opt);
                    });
                };
                document.getElementById('saveAssignGroupsBtn').onclick = () => this.saveAssignedGroups();
                modal.show();
            }
            saveAssignedGroups() {
                const selectedSelect = document.getElementById('assign-selected-groups');
                const selected = Array.from(selectedSelect.options).map(opt => opt.value);
                if (
                    this._lastCategories &&
                    this._assignGroupsCatIdx != null &&
                    this._assignGroupsSubIdx != null &&
                    this._lastCategories[this._assignGroupsCatIdx] &&
                    this._lastCategories[this._assignGroupsCatIdx].subcategories &&
                    this._lastCategories[this._assignGroupsCatIdx].subcategories[this._assignGroupsSubIdx]
                ) {
                    this._lastCategories[this._assignGroupsCatIdx].subcategories[this._assignGroupsSubIdx].groups = selected;
                    this.saveCategoriesToServer();
                }
                bootstrap.Modal.getInstance(document.getElementById('assignGroupsModal')).hide();
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            window.app = new MikroTikSPA();
            
            // Load saved refresh interval or default to 5 seconds
            const savedInterval = localStorage.getItem('refreshInterval');
            if (savedInterval) {
                window.app.setRefreshInterval(parseInt(savedInterval));
            } else {
                // Default to 5 seconds if no saved interval
                window.app.setRefreshInterval(5);
            }
        });

        // Add modal HTML for assign groups (injectCategoryModals)
        if (!document.getElementById('assignGroupsModal')) {
            const assignGroupsModalHtml = `
            <div class="modal fade" id="assignGroupsModal" tabindex="-1" aria-labelledby="assignGroupsModalLabel" aria-hidden="true">
              <div class="modal-dialog">
                <div class="modal-content">
                  <div class="modal-header">
                    <h5 class="modal-title" id="assignGroupsModalLabel">Assign Groups</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                  </div>
                  <div class="modal-body">
                    <div class="row">
                      <div class="col-5">
                        <label class="form-label text-muted">Available Groups</label>
                        <select id="assign-available-groups" class="form-select" size="8" multiple></select>
                      </div>
                      <div class="col-2 d-flex flex-column justify-content-center align-items-center">
                        <button type="button" class="btn btn-sm btn-outline-primary mb-2" id="assign-add-groups">
                          <i class="bi bi-arrow-right"></i>
                        </button>
                        <button type="button" class="btn btn-sm btn-outline-secondary" id="assign-remove-groups">
                          <i class="bi bi-arrow-left"></i>
                        </button>
                      </div>
                      <div class="col-5">
                        <label class="form-label text-muted">Assigned Groups</label>
                        <select id="assign-selected-groups" class="form-select" size="8" multiple></select>
                      </div>
                    </div>
                  </div>
                  <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="saveAssignGroupsBtn">Save</button>
                  </div>
                </div>
              </div>
            </div>
            `;
            document.body.insertAdjacentHTML('beforeend', assignGroupsModalHtml);
        }
    </script>
</body>
</html> 
</html> 